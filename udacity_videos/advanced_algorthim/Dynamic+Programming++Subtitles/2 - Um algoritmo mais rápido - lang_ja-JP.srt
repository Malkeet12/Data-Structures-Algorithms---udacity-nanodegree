1
00:00:00,710 --> 00:00:02,500
もっとスマートなアプローチについて説明しましょう。

2
00:00:03,600 --> 00:00:07,345
最初の目標は
考えられる最大の重さの値を

3
00:00:07,345 --> 00:00:09,422
最大化することである必要はありません。

4
00:00:09,422 --> 00:00:13,905
考えられる最小の重さの値の最大化を
試行したらどうなるでしょうか。

5
00:00:13,905 --> 00:00:17,823
そして最大の重さになるまで
それらを合計し続けます。

6
00:00:17,823 --> 00:00:20,120
例を見てみましょう。

7
00:00:20,120 --> 00:00:24,260
まずは配列を作成します。
これを使って重量上限の範囲内で

8
00:00:24,260 --> 00:00:27,100
それぞれの重さを
考えられる最大値として保存します。

9
00:00:28,150 --> 00:00:31,470
重量は
すべて正の整数になり

10
00:00:31,470 --> 00:00:34,890
配列のインデックスは
重さを表すと想定します。

11
00:00:35,180 --> 00:00:37,600
ここでは、まずゼロから
始めます。

12
00:00:38,200 --> 00:00:41,960
これらのオブジェクトは
重量上限が 6 のナップザックへの

13
00:00:41,960 --> 00:00:42,600
適合を試行しています。

14
00:00:43,690 --> 00:00:45,790
重量 2 のオブジェクトを
とりあげます。

15
00:00:46,990 --> 00:00:50,810
インデックス 2 の値を
オブジェクトの値に更新できます。

16
00:00:52,230 --> 00:00:55,180
そして同じ値を使用して
それ以降のすべてを更新します。

17
00:00:56,350 --> 00:01:00,390
ナップサックが重量 6 を保持できたとしても
オブジェクトは 1 つしか見えないので

18
00:01:00,390 --> 00:01:04,550
その 1 つのオブジェクトからの
最善の値をベースにする必要があります。

19
00:01:05,680 --> 00:01:07,660
次のオブジェクトを見てみます。

20
00:01:07,660 --> 00:01:10,585
インデックス 5 まで
何も変更できません。

21
00:01:10,585 --> 00:01:14,934
このオブジェクトの値は
最大値より大きく

22
00:01:14,935 --> 00:01:17,150
全体の重量を占めています。

23
00:01:17,150 --> 00:01:19,995
ですから重さ 5 と 6 の
最大値を置換します。

24
00:01:19,995 --> 00:01:26,750
最後のオブジェクトについては、まず
変更可能な点はインデックス 4 です。

25
00:01:26,750 --> 00:01:29,235
この値はそれよりも小さいので
このままにしておきます。

26
00:01:30,510 --> 00:01:35,890
インデックス 5 を見てそれをインデックス 1 の値を
加えた値と比較します。

27
00:01:35,890 --> 00:01:40,288
古い値のほうが大きいため
そのままにしておきます。

28
00:01:40,288 --> 00:01:45,540
インデックス 6 でオブジェクト値を
インデックス 2 の値に加えると

29
00:01:45,550 --> 00:01:50,480
より大きな値になるので
これを置換します。

30
00:01:50,480 --> 00:01:52,620
これで問題は解決しました。

31
00:01:52,620 --> 00:01:56,700
この例の小さな値では
不要に思えるかもしれませんが、

32
00:01:56,700 --> 00:01:59,910
多数のブジェクトの場合
どれだけの時間が節約できるでしょうか。

33
00:01:59,910 --> 00:02:02,500
ここではテーブルを利用して
事前計算済みの

34
00:02:02,500 --> 00:02:04,360
最大値を格納しています。

35
00:02:05,430 --> 00:02:08,449
よってこれらの数値を取得するために
必要なものはこの作業だけです。

36
00:02:09,600 --> 00:02:14,220
すべてのオブジェクトを試行し
重量上限の範囲内で考えられる

37
00:02:14,220 --> 00:02:16,880
それぞれの重さの最大値
が増加できるかどうかを確認します。

38
00:02:18,130 --> 00:02:22,650
よってランタイムは n 掛ける W
ここでの W は

39
00:02:22,650 --> 00:02:25,919
ナップサックの重量上限で
n は要素の数です。

40
00:02:27,140 --> 00:02:30,640
これは疑似多項式
時間ソリューションです。

41
00:02:30,640 --> 00:02:34,459
真の多項式ランタイムは
n 以外に変数を持ちません。

42
00:02:35,870 --> 00:02:40,120
繰り返しますが、大きな数に対しては
多項式時間アルゴリズムは

43
00:02:40,120 --> 00:02:43,140
指数時間アルゴリズムより
スピーディーです。

44
00:02:43,140 --> 00:02:45,339
よってこのソリューションは
迅速だと言えます。

