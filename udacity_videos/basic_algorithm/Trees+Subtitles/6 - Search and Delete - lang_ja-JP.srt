1
00:00:00,300 --> 00:00:05,399
バイナリーツリーはシンプルな構造で
親が子ノードを 2 つ持つのが通常です

2
00:00:05,400 --> 00:00:10,500
これはノードが子を 0、1 または 2 つ
持つ可能性があることを意味します

3
00:00:10,500 --> 00:00:13,330
これらの子は null の場合もありますが
問題ありません

4
00:00:13,330 --> 00:00:16,200
バイナリーツリーでは
検索がどのようになるか見てみましょう

5
00:00:16,200 --> 00:00:19,490
トラバーサルアルゴリズムを使って
ツリー全体を

6
00:00:19,490 --> 00:00:20,669
見てみましょう

7
00:00:20,670 --> 00:00:24,460
要素には実際の順番はないため
探している値が存在しない場合は

8
00:00:24,460 --> 00:00:28,880
ツリーのすべての単一要素を
見ていく必要があります

9
00:00:28,880 --> 00:00:32,119
気の利いたトリックはないので
時間の線形探索を実行するのみです

10
00:00:33,340 --> 00:00:37,230
削除したいノードを
見つける必要があるので

11
00:00:37,230 --> 00:00:38,290
削除操作は検索から始めます

12
00:00:38,290 --> 00:00:41,740
葉を削除したい場合は
単純にそれを削除して先に進みます

13
00:00:41,740 --> 00:00:46,180
ですが内部ノードを削除する場合は
ツリーに突然ギャップが生まれます

14
00:00:46,180 --> 00:00:50,550
子を 1 つだけしか持たないノードを削除した場合は
それを取り除いて子をレベルアップし

15
00:00:50,550 --> 00:00:54,930
古いノードの親に
アタッチします

16
00:00:54,930 --> 00:00:57,600
子を 2 つ持つノードの削除を
試行する場合は

17
00:00:57,600 --> 00:00:59,220
いくつかのオプションがあります

18
00:00:59,220 --> 00:01:02,730
先程の説明のように
子をレベルアップさせます

19
00:01:02,730 --> 00:01:05,330
もちろんいつも簡単にいくわけではありません

20
00:01:05,330 --> 00:01:08,950
両方の子がそれぞれ
2 つの子を持っていたらどうでしょう

21
00:01:08,950 --> 00:01:09,980
最悪の場合

22
00:01:09,980 --> 00:01:13,900
葉にぶつかるまで
サブツリーをたどっていく必要があります

23
00:01:13,900 --> 00:01:16,430
ここには実際の順番要件は
ないので

24
00:01:16,430 --> 00:01:20,900
削除されたノードのリーフを
問題なく配置できます

25
00:01:20,900 --> 00:01:23,480
検索が含まれ
削除後に要素を移動する追加作業があるため

26
00:01:23,480 --> 00:01:26,130
ランタイムは
線形になります

